"""Action decoder for converting VLM outputs to structured actions."""

from typing import Dict, Any
import json
import re


class ActionDecoder:
    """
    Helper class to decode model outputs into structured actions.

    Handles parsing of generated text into action dictionaries
    for the UI environment.
    """

    def __init__(self, action_format: str = "json"):
        """
        Args:
            action_format: Format for actions ("json", "text", "coordinates")
        """
        self.action_format = action_format

    def decode(self, generated_text: str) -> Dict[str, Any]:
        """
        Parse generated text into action dictionary.

        Args:
            generated_text: Text generated by VLM

        Returns:
            Action dictionary, e.g., {"type": "click", "x": 100, "y": 200}
        """
        if self.action_format == "json":
            return self._decode_json(generated_text)
        elif self.action_format == "text":
            return self._decode_text(generated_text)
        elif self.action_format == "coordinates":
            return self._decode_coordinates(generated_text)
        else:
            raise ValueError(f"Unknown action format: {self.action_format}")

    def _decode_json(self, text: str) -> Dict[str, Any]:
        """Decode JSON-formatted action."""
        # Try to find JSON in text
        json_match = re.search(r'\{.*\}', text, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group(0))
            except json.JSONDecodeError:
                pass

        # Default fallback
        return {"type": "none", "error": "Failed to parse action"}

    def _decode_text(self, text: str) -> Dict[str, Any]:
        """Decode text-formatted action like 'click(100, 200)'."""
        # Match pattern: action_type(param1, param2, ...)
        match = re.match(r'(\w+)\((.*?)\)', text.strip())

        if match:
            action_type = match.group(1)
            params_str = match.group(2)

            # Parse parameters
            params = [p.strip() for p in params_str.split(',') if p.strip()]

            # Map to action dict based on type
            if action_type == "click" and len(params) >= 2:
                return {
                    "type": "click",
                    "x": int(params[0]),
                    "y": int(params[1])
                }
            elif action_type == "type" and len(params) >= 1:
                return {
                    "type": "type",
                    "text": params[0].strip('"\'')
                }
            elif action_type == "scroll" and len(params) >= 1:
                return {
                    "type": "scroll",
                    "direction": params[0],
                    "amount": int(params[1]) if len(params) > 1 else 100
                }

        return {"type": "none", "error": "Failed to parse action"}

    def _decode_coordinates(self, text: str) -> Dict[str, Any]:
        """Decode coordinate-based action like '<x> <y> click'."""
        # Match pattern: number number action
        match = re.search(r'(\d+)\s+(\d+)\s+(\w+)', text)

        if match:
            x, y, action_type = match.groups()
            return {
                "type": action_type,
                "x": int(x),
                "y": int(y)
            }

        return {"type": "none", "error": "Failed to parse coordinates"}
